Command Pattern
================================================================

<p align="center"><img src="Command.gif" width="80%" height="70%" title="Command 클래스 다이어그램" alt="Command 클래스 다이어그램"></img></p>

<strong>커맨드 패턴</strong>(Command)이란 요청을 객체의 형태로 캡슐화하여 사용자가 보낸 요청을 나중에 이용할 수 있도록 매서드 이름,매개변수 등 요청에 필요한 정보를 저장 
또는 로깅,취소할 수 있게 하는 패턴이다.   
커맨드 패턴에는 명령(Command), 수신자(Receiver), 발동자(Invoker), 클라이언트(Client)의 네개의 용어가 항상 따른다. 커맨드 객체는 수신자 객체를 가지고 있으며, 수신자의 
메서드를 호출하고, 이에 수신자는 자신에게 정의된 메서드를 수행한다. 커맨드 객체는 별도로 발동자 객체에 전달되어 명령을 발동하게 한다. 발동자 객체는 필요에 따라 명령 발동에 대한
기록을 남길 수 있다. 한 발동자 객체의 다수의 커맨드 객체가 전달될 수 있다. 클라이언트 객체는 발동자 객체와 하나 이상의 커맨드 객체를 보유한다. 클라이언트 객체는 어느 시점에서 어떤 명령을
수행할지를 결정한다. 명령을 수행하려면, 클라이언트 객체는 발동자 객체로 커맨드 객체를 전달한다.

### 의도
요청 자체를 캡슐화하는 것입니다. 이를 통해 요청이 서로 다른 사용자를 매개변수로 만들고, 요청을 대기키거나 로깅하며, 되돌릴 수 있는 연산을 지원합니다.

### 활용성
명령 패턴은 다음과 같은 일을 하고 싶을 때 사용합니다.   

1.수행할 동작을 객체로 매개변수화하고자 할 때. 절차지향 프로그램에서는 이를 <strong>콜백(Callback)</strong> 함수, 즉 어딘가 등록되었다가 나중에 호출되는 함수를 사용해서 이러한 매개변수화를 표현할 수 있습니다.
명령 패턴은 콜백을 객체지향 방식으로 나타낸 것입니다.

2.서로 다른 시간에 요청을 명시하고, 저장하며, 실행하고 싶을 때. Command 객체는 원래의 요청과 다른 생명주기(LifeTime)가 있습니다. 요청을 받아 처리하는 객체가 주소 지정 방식과는 독립적으로 표현될 수 있다면,
Command 객체를 다른 프로세스에게 넘겨주고 거기서 해당 처리를 진행하게 할 수 있습니다.

3.실행 취소 기능을 지원하고 싶을 때. Command의 Execute() 연산은 상태를 저장할 수 있는데, 이를 이용해서 지금까지 얻은 결과를 바꿀 수 있습니다. 이를 위해 UnExecute() 연산을 Command 클래스의 인터페이스에 추가합니다.    
실행된 명령어를 모두 기록해 두었다가 이 리스트를 역으로 탐색해서 다시 UnExecute()를 수행하게 합니다. Execute()와 UnExecute() 연산의 반복 사용을 통해 수행과 취소를 무한 반복할 수 있습니다.

4.시스템이 고장 났을 때 재적용이 가능하도록 변경 과정에 대한 로깅을 지원하고 싶을 때, Command 인터페이스를 확장해서 Load()와 Store() 연산을 정의하면 상태의 변화를 지속적(Persistent) 저장소에 저장해 둘 수 있습니다.   
시스템 장애가 발생했을 때 해당 저장소에서 저장된 명령어를 읽어 다시 Execute() 연산을 통해 재실행하면 됩니다.

5.기본적인 연산의 조합으로 만든 상위 수준 연산을 써서 시스템을 구조화하고 싶을 때. 정보 시스템의 일반적인 특성은 <strong>트랜잭션</strong>(Transaction)을 처리해야 한다는 것입니다. 트랜잭션은 일련의 과정을 통해   
데이터를 변경하는 것인데, Command 패턴은 이런 트랜잭션의 모델링을 가능하게 합니다. Command 클래스는 일관된 인터페이스를 정의하는데, 이로써 모든 트랜잭션이 동일한 방식으로 호출됩니다. 새로운 트랜잭션을 만들면 상속으로    
Command 클래스를 확장하면 되므로 시스템 확장도 어렵지 않습니다.

### 결과

1. Command는 연산을 호출하는 객체와 연산 수행 방법을 구현하는 객체를 분리합니다.   
2. Command는 일급 클래스입니다. 다른 객체와 같은 방식으로 조작되고 확장 할 수 있습니다.   
3. 명령어 여러 개를 복합해서 복합 명령을 만들 수 있습니다. 복합체 패턴을 이용하여 여러 명령어를 구성할 수 있습니다.
4. 새로운 Command 객체를 추가하기 쉽습니다. 기존 클래스를 변경할 필요없이 단지 새로운 명령어에 대응하는 클래스만 정의하면 됩니다.

### 구현

1. <strong>명령이 얼마나 지능적이어야 할까?</strong> 명령어는 다양한 기능을 갖는데, 가장 대표적인 것이 처리 요청을 수행하는 액션과 이를 받는 객체 사이의 연결 관계를 정의하는 것입니다.
   또 수신 객체에 대한 어떤 요청의 전달 없이도 자신이 모든 것을 처리할 수 있기도 합니다. 명령 패턴은 수신 객체를 동적으로 발견할 수 있는 능력을 지녀야 합니다.   

2. <strong>취소</strong>(Undo) <strong>및 반복</strong>(Redo) 연산 지원하기, 명령어가 지금까지 수행해 온 것을 뒤집는 방법을 제공한다면 가능한 일입니다. ConcreteCommand 클래스는 이러한 취소와 반복을 처리하기 위해서
   추가적으로 상태 정보를 관리해야 합니다.   
   + 실제 요청을 처리할 책임을 지는 수신 객체
   + 수신 객체가 수행할 연산에 필요한 매개변수 정보
   + 요청이 처리되어 변하기 전의 원래 값. 수신 객체는 명령어가 이전의 상태로 되돌아갈 수 있도록 하는 연산을 정의해야 합니다.   
   
3. <strong>취소를 진행하는 도중 오류가 누적되는 것 피하기.</strong> 처리 내역의 이력을 관리할 때 문제가 될 수 있는 부분은 신뢰성을 보장하면서 처리된 의미들을 유지한채 수행/취소 처리가 되어야 한다는 것. 명령어를 처리하면서
   자꾸 오류가 발생할 수 있는데, 오류의 발생이 수행/취소를 거듭하여 누적되면 응용프로그램의 상태는 초기 상태에서 멀어지므로 객체가 처리 결과를 취소했을 때 원로의 상태로 복귀했는지 확인하는 작업이 필요합니다.   

### 시나리오
